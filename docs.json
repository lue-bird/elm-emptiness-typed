[{"name":"HoleyFocusList","comment":" A list zipper which can also focus on a hole _between_ items.\n\n1.  ğŸ” focus on a hole between two items\n2.  ğŸ”Œ plug that hole with a value\n3.  ğŸ’° profit\n\n\n## types\n\n@docs HoleyFocusList, Item, HoleOrItem\n\n\n## create\n\n@docs empty, only\n\n\n## scan\n\n@docs current, before, after\n\n\n## navigate\n\n@docs next, previous, nextHole, previousHole\n@docs first, last, beforeFirst, afterLast\n@docs findForward, findBackward\n\n\n## modify\n\n@docs append, prepend\n\n\n## around focus\n\n@docs mapCurrent, plug, remove\n@docs mapBefore, mapAfter\n@docs insertAfter, insertBefore\n@docs squeezeInBefore, squeezeInAfter\n\n\n## transform\n\n@docs map, mapParts, joinParts, toList\n\n\n## type-level\n\n@docs focussesItem, branchableType\n\n","unions":[{"name":"HoleyFocusList","comment":" Represents a special kind of list with items of type `a`.\n\nThe type `focus` can be\n\n  - [`Item`](#Item): `ğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡`\n\n  - [`HoleOrItem`](#HoleOrItem): `ğŸ ğŸ“ <?> ğŸ‰ ğŸ‡`\n\n    `<?>` means both are possible:\n\n      - `ğŸ ğŸ“ <> ğŸ‰ ğŸ‡`: a hole between items\n      - `ğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡`\n\n","args":["focus","a"],"cases":[]}],"aliases":[{"name":"HoleOrItem","comment":" A `HoleyFocusList HoleOrItem a` could be focussed on a hole between `a`s.\n\n... Heh.\n\n```monospace\nğŸ ğŸ“ <?> ğŸŠ ğŸ‰ ğŸ‡\n```\n\n`<?>` means both are possible:\n\n    - `ğŸ ğŸ“ <> ğŸ‰ ğŸ‡`: a hole between items\n    - `ğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡`\n\n","args":[],"type":"MaybeIs.Nothingable { holeOrItem : () }"},{"name":"Item","comment":" A `HoleyFocusList Item a` is focussed on an element of type `a`.\n\n```monospace\nğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡\n```\n\n","args":[],"type":"MaybeIs.Just { item : () }"}],"values":[{"name":"after","comment":" The items after the current focussed location in the `HoleyFocusList`.\n\n```monospace\nğŸ ğŸ“ <ğŸŠ> (ğŸ‰ ğŸ‡\n```\n\n    HoleyFocusList.only 0\n        |> HoleyFocusList.append [ 1, 2, 3 ]\n        |> HoleyFocusList.next\n        |> Maybe.map HoleyFocusList.after\n    --> Just [ 2, 3 ]\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> List.List a"},{"name":"afterLast","comment":" Focus the hole after the end of the `HoleyFocusList`. Into the nothingness.\n\n```monospace\nğŸ ğŸ“ <ğŸŠ> ğŸ‰  ->  ğŸ ğŸ“ ğŸŠ ğŸ‰ <>\n```\n\n    import ListIs\n\n    HoleyFocusList.only 1                 -- <1>\n        |> HoleyFocusList.append [ 2, 3 ] -- <1> 2 3\n        |> HoleyFocusList.afterLast       -- 1 2 3 <>\n        |> HoleyFocusList.plug 4          -- 1 2 3 <4>\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 1 [ 2, 3, 4 ]\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a"},{"name":"append","comment":" Put items to the end of the `HoleyFocusList`. After anything else.\n\n```monospace\n                 ğŸ’ğŸ‹\nğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡ â†“/\n```\n\n    import ListIs\n\n    HoleyFocusList.only 123\n        |> HoleyFocusList.append [ 456 ]\n        |> HoleyFocusList.append [ 789, 0 ]\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 123 [ 456, 789, 0 ]\n\n","type":"List.List a -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"before","comment":" The items before the location of the focus in the `HoleyFocusList`.\n\n```monospace\nğŸ ğŸ“) <ğŸŠ> ğŸ‰ ğŸ‡\n```\n\n    HoleyFocusList.only 0\n        |> HoleyFocusList.append [ 1, 2, 3 ]\n        |> HoleyFocusList.next\n        |> Maybe.andThen HoleyFocusList.next\n        |> Maybe.map HoleyFocusList.before\n    --> Just [ 0, 1 ]\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> List.List a"},{"name":"beforeFirst","comment":" Focus the hole before the first item.\nRemember that holes surround everything!\n\n```monospace\nğŸ ğŸ“ <ğŸŠ> ğŸ‰  ->  <> ğŸ ğŸ“ ğŸŠ ğŸ‰\n```\n\n    import ListIs\n\n    HoleyFocusList.only 1                 -- <1>\n        |> HoleyFocusList.append [ 3, 4 ] -- <1> 3 4\n        |> HoleyFocusList.nextHole        -- 1 <> 3 4\n        |> HoleyFocusList.plug 2          -- 1 <2> 3 4\n        |> HoleyFocusList.beforeFirst     -- <> 1 2 3 4\n        |> HoleyFocusList.plug 0          -- <0> 1 2 3 4\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 0 [ 1, 2, 3, 4 ]\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a"},{"name":"branchableType","comment":" When using a `HoleyFocusList Item ...` argument,\nits type can't be unified with non-`Item` lists.\n\nPlease read more at [`MaybeIs.branchableType`](MaybeIs#branchableType).\n\n","type":"HoleyFocusList.HoleyFocusList HoleyFocusList.Item a -> HoleyFocusList.HoleyFocusList item_ a"},{"name":"current","comment":" The current focussed item in the `HoleyFocusList`.\n\n```monospace\nğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡  ->  ğŸŠ\n```\n\n    HoleyFocusList.only \"hi there\"\n        |> HoleyFocusList.current\n    --> \"hi there\"\n\n    HoleyFocusList.only 1\n        |> HoleyFocusList.append [ 2, 3, 4 ]\n        |> HoleyFocusList.last\n        |> HoleyFocusList.current\n    --> 4\n\n","type":"HoleyFocusList.HoleyFocusList HoleyFocusList.Item a -> a"},{"name":"empty","comment":" An empty `HoleyFocusList` focussed on a hole with nothing before\nand after it.\nIt's the loneliest of all `HoleyFocusList`s.\n\n```monospace\n<>\n```\n\n    import ListIs\n\n    HoleyFocusList.empty\n        |> HoleyFocusList.joinParts\n    --> ListIs.empty\n\n","type":"HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a_"},{"name":"findBackward","comment":" Find the first item in the `HoleyFocusList` matching a predicate, moving backwards\nfrom the current position.\n\n    HoleyFocusList.only 4\n        |> HoleyFocusList.prepend [ 2, -1, 0, 3 ]\n        |> HoleyFocusList.findBackward (\\item -> item < 0)\n        |> Maybe.map HoleyFocusList.current\n    --> Just -1\n\n","type":"(a -> Basics.Bool) -> HoleyFocusList.HoleyFocusList focus_ a -> Maybe.Maybe (HoleyFocusList.HoleyFocusList item_ a)"},{"name":"findForward","comment":" Find the first item in the `HoleyFocusList` the matches a predicate, returning a\n`HoleyFocusList` focussed on that item if it was found.\n\nThis start from the current focussed location and searches towards the end.\n\n    HoleyFocusList.only 4\n        |> HoleyFocusList.append [ 2, -1, 0, 3 ]\n        |> HoleyFocusList.findForward (\\item -> item < 0)\n        |> Maybe.map HoleyFocusList.current\n    --> Just -1\n\n    HoleyFocusList.only -4\n        |> HoleyFocusList.append [ 2, -1, 0, 3 ]\n        |> HoleyFocusList.findForward (\\item -> item < 0)\n        |> Maybe.map HoleyFocusList.current\n    --> Just -4\n\n","type":"(a -> Basics.Bool) -> HoleyFocusList.HoleyFocusList focus_ a -> Maybe.Maybe (HoleyFocusList.HoleyFocusList item_ a)"},{"name":"first","comment":" Focus the first item in the `HoleyFocusList`.\n\n```monospace\nğŸ ğŸ“ <ğŸŠ> ğŸ‰  ->  <ğŸ> ğŸ“ ğŸŠ ğŸ‰\n```\n\n    HoleyFocusList.only 1\n        |> HoleyFocusList.append [ 2, 3, 4 ]\n        |> HoleyFocusList.prepend [ 4, 3, 2 ]\n        |> HoleyFocusList.first\n        |> HoleyFocusList.current\n    --> 4\n\n","type":"HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"focussesItem","comment":" Find out if the current focussed thing is an item.\n\n    HoleyFocusList.only 3\n        |> HoleyFocusList.append [ 2, 1 ]\n        |> HoleyFocusList.nextHole\n        |> HoleyFocusList.focussesItem\n    --> MaybeIs.nothing\n\n","type":"HoleyFocusList.HoleyFocusList (MaybeIs.CanBeNothing valueIfNothing focusTag_) a -> MaybeIs.MaybeIs (MaybeIs.CanBeNothing valueIfNothing emptyOrNotTag_) (HoleyFocusList.HoleyFocusList item_ a)"},{"name":"insertAfter","comment":" Insert an item after the focussed location.\n\n```monospace\n           ğŸ’\nğŸ ğŸ“ <ğŸŠ> â†“ ğŸ‰ ğŸ‡\n```\n\n    import ListIs\n\n    HoleyFocusList.only 123\n        |> HoleyFocusList.append [ 789 ]\n        |> HoleyFocusList.insertAfter 456\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 123 [ 456, 789 ]\n\nInsert multiple items using [`squeezeInAfter`](#squeezeInAfter).\n\n","type":"a -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"insertBefore","comment":" Insert an item before the focussed location.\n\n```monospace\n      ğŸ’\nğŸ ğŸ“ â†“ <ğŸŠ> ğŸ‰ ğŸ‡\n```\n\n    import ListIs\n\n    HoleyFocusList.only 123\n        |> HoleyFocusList.insertBefore 456\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 456 [ 123 ]\n\nInsert multiple items using [`squeezeInBefore`](#squeezeInBefore).\n\n","type":"a -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"joinParts","comment":" Flattens the `HoleyFocusList` into a [`ListIs`](ListIs):\n\n    import ListIs\n\n    HoleyFocusList.empty\n        |> HoleyFocusList.joinParts\n    --> ListIs.empty\n\n    HoleyFocusList.only 123\n        |> HoleyFocusList.append [ 789 ]\n        |> HoleyFocusList.nextHole\n        |> HoleyFocusList.plug 456\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 123 [ 456, 789 ]\n\nthe type information gets carried over, so\n\n    Item -> ListIs.NotEmpty\n    HoleOrItem -> ListIs.Emptiable\n\n","type":"HoleyFocusList.HoleyFocusList (MaybeIs.CanBeNothing valueIfNothing focusTag_) a -> ListIs.ListIs (MaybeIs.CanBeNothing valueIfNothing emptyOrNotTag_) a"},{"name":"last","comment":" Focus the last item in the `HoleyFocusList`.\n\n```monospace\nğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡  ->  ğŸ“ ğŸŠ ğŸ‰ <ğŸ‡>\n```\n\n    HoleyFocusList.only 1\n        |> HoleyFocusList.append [ 2, 3, 4 ]\n        |> HoleyFocusList.last\n        |> HoleyFocusList.current\n    --> 4\n\n    HoleyFocusList.only 1\n        |> HoleyFocusList.append [ 2, 3, 4 ]\n        |> HoleyFocusList.last\n        |> HoleyFocusList.before\n    --> [ 1, 2, 3 ]\n\n","type":"HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"map","comment":" Execute a function on every item in the `HoleyFocusList`.\n\n    import ListIs\n\n    HoleyFocusList.only \"first\"\n        |> HoleyFocusList.prepend [ \"zeroth\" ]\n        |> HoleyFocusList.append [ \"second\", \"third\" ]\n        |> HoleyFocusList.map String.toUpper\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons \"ZEROTH\" [ \"FIRST\", \"SECOND\", \"THIRD\" ]\n\n","type":"(a -> b) -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus b"},{"name":"mapAfter","comment":" Apply a function to all items coming after the current focussed location.\n\n    import ListIs\n\n    HoleyFocusList.only \"zeroth\"\n        |> HoleyFocusList.append [ \"first\", \"second\" ]\n        |> HoleyFocusList.mapAfter String.toUpper\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons \"zeroth\" [ \"FIRST\", \"SECOND\" ]\n\n","type":"(a -> a) -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"mapBefore","comment":" Apply a function to all items coming before the current focussed location.\n\n    import ListIs\n\n    HoleyFocusList.only \"second\"\n        |> HoleyFocusList.prepend [ \"zeroth\", \"first\" ]\n        |> HoleyFocusList.mapBefore String.toUpper\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons \"ZEROTH\" [ \"FIRST\", \"second\" ]\n\n","type":"(a -> a) -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"mapCurrent","comment":" If an item is focussed in the `HoleyFocusList`, apply a function to it.\n\n    import ListIs\n\n    HoleyFocusList.only \"first\"\n        |> HoleyFocusList.prepend [ \"zeroth\" ]\n        |> HoleyFocusList.append [ \"second\", \"third\" ]\n        |> HoleyFocusList.mapCurrent String.toUpper\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons \"zeroth\" [ \"FIRST\", \"second\", \"third\" ]\n\n","type":"(a -> a) -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"mapParts","comment":" Apply multiple different functions on the parts of a `HoleyFocusList` - what\ncomes before, what comes after, and the current item if there is one.\n\n    import ListIs\n\n    HoleyFocusList.only \"first\"\n        |> HoleyFocusList.append [ \"second\" ]\n        |> HoleyFocusList.nextHole\n        |> HoleyFocusList.plug \"one-and-a-halfth\"\n        |> HoleyFocusList.mapParts\n            { before = (++) \"before: \"\n            , current = (++) \"current: \"\n            , after = (++) \"after: \"\n            }\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons\n    -->     \"before: first\"\n    -->     [ \"current: one-and-a-halfth\"\n    -->     , \"after: second\"\n    -->     ]\n\n","type":"{ before : a -> b, current : a -> b, after : a -> b } -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus b"},{"name":"next","comment":" Move the focus of the `HoleyFocusList` to the next item, if there is one.\n\n```monospace\n<ğŸŠ> ğŸ‰ ğŸ‡  ->  ğŸŠ <ğŸ‰> ğŸ‡\n```\n\n    HoleyFocusList.only 0\n        |> HoleyFocusList.append [ 1, 2, 3 ]\n        |> HoleyFocusList.next\n        |> Maybe.map HoleyFocusList.current\n    --> Just 1\n\nThis also works from within holes:\n\n    HoleyFocusList.empty\n        |> HoleyFocusList.insertAfter \"foo\"\n        |> HoleyFocusList.next\n    --> Just (HoleyFocusList.only \"foo\")\n\nIf there is no `next` item, the result is `Nothing`.\n\n    HoleyFocusList.empty\n        |> HoleyFocusList.next\n    --> Nothing\n\n\n    HoleyFocusList.only 0\n        |> HoleyFocusList.append [ 1, 2, 3 ]\n        |> HoleyFocusList.last\n        |> HoleyFocusList.next\n    --> Nothing\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> Maybe.Maybe (HoleyFocusList.HoleyFocusList item_ a)"},{"name":"nextHole","comment":" Move the `HoleyFocusList` to the hole right after the current item. A hole is a whole\nlot of nothingness, so it's always there.\n\n```monospace\nğŸ <ğŸŠ> ğŸ‰  ->  ğŸ ğŸŠ <> ğŸ‰\n```\n\n    import ListIs\n\n    HoleyFocusList.only \"hello\"\n        |> HoleyFocusList.append [ \"world\" ]\n        |> HoleyFocusList.nextHole\n        |> HoleyFocusList.plug \"holey\"\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons \"hello\" [ \"holey\", \"world\" ]\n\n","type":"HoleyFocusList.HoleyFocusList HoleyFocusList.Item a -> HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a"},{"name":"only","comment":" A `HoleyFocusList` with a single focussed item in it, nothing before and after it.\n\n```monospace\n<ğŸŠ>\n```\n\n    import ListIs\n\n    HoleyFocusList.only \"wat\"\n        |> HoleyFocusList.current\n    --> \"wat\"\n\n    HoleyFocusList.only \"wat\"\n        |> HoleyFocusList.joinParts\n    --> ListIs.only \"wat\"\n\n","type":"a -> HoleyFocusList.HoleyFocusList item_ a"},{"name":"plug","comment":" Fill in or replace the focussed thing in the `HoleyFocusList`.\n\n```monospace\n       ğŸ’\nğŸ ğŸ“ <ğŸ¡‡> ğŸ‰ ğŸ‡\n```\n\n    import ListIs\n\n    HoleyFocusList.plug \"plug\" HoleyFocusList.empty\n    --> HoleyFocusList.only \"plug\"\n\n","type":"a -> HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a -> HoleyFocusList.HoleyFocusList item_ a"},{"name":"prepend","comment":" Put items to the beginning of the `HoleyFocusList`. Before anything else.\n\n```monospace\nğŸ’ğŸ‹\n \\â†“ ğŸ ğŸ“ <ğŸŠ> ğŸ‰ ğŸ‡\n```\n\n    import ListIs\n\n    HoleyFocusList.only 1\n        |> HoleyFocusList.append [ 2, 3, 4 ]\n        |> HoleyFocusList.last\n        |> HoleyFocusList.prepend [ 5, 6, 7 ]\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 5 [ 6, 7, 1, 2, 3, 4 ]\n\n","type":"List.List a -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"previous","comment":" Move the focus of the `HoleyFocusList` to the previous item, if there is one.\n\n```monospace\nğŸ <ğŸŠ> ğŸ‰  ->  <ğŸ> ğŸŠ ğŸ‰\n```\n\n    HoleyFocusList.empty |> HoleyFocusList.previous\n    --> Nothing\n\n    HoleyFocusList.only \"hello\"\n        |> HoleyFocusList.append [ \"holey\", \"world\" ]\n        |> HoleyFocusList.last\n        |> HoleyFocusList.previous\n        |> Maybe.map HoleyFocusList.current\n    --> Just \"holey\"\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> Maybe.Maybe (HoleyFocusList.HoleyFocusList item_ a)"},{"name":"previousHole","comment":" Move the `HoleyFocusList` to the hole right before the current item. Feel free to plug\nthat hole right up!\n\n```monospace\nğŸ <ğŸŠ> ğŸ‰  ->  ğŸ <> ğŸŠ ğŸ‰\n```\n\n    import ListIs\n\n    HoleyFocusList.only \"world\"\n        |> HoleyFocusList.previousHole\n        |> HoleyFocusList.plug \"hello\"\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons \"hello\" [ \"world\" ]\n\n","type":"HoleyFocusList.HoleyFocusList HoleyFocusList.Item a -> HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a"},{"name":"remove","comment":" Punch a hole into the `HoleyFocusList` by removing the focussed thing.\n\n```monospace\nğŸ“ <?> ğŸ‰  ->  ğŸ“ <> ğŸ‰\n```\n\n    HoleyFocusList.only \"hello\"\n        |> HoleyFocusList.append [ \"holey\", \"world\" ]\n        |> HoleyFocusList.next\n        |> Maybe.map HoleyFocusList.remove\n        |> Maybe.map HoleyFocusList.toList\n    --> Just [ \"hello\", \"world\" ]\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> HoleyFocusList.HoleyFocusList HoleyFocusList.HoleOrItem a"},{"name":"squeezeInAfter","comment":" Append items directly after the focussed location in the `HoleyFocusList`.\n\n```monospace\n           ğŸ’ğŸ‹\nğŸ ğŸ“ <ğŸŠ> \\â†“/ ğŸ‰ ğŸ‡\n```\n\n    import ListIs\n\n    HoleyFocusList.only 0\n        |> HoleyFocusList.squeezeInAfter [ 4, 5 ]\n        |> HoleyFocusList.squeezeInAfter [ 1, 2, 3 ]\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons 0 [ 1, 2, 3, 4, 5 ]\n\n","type":"List.List a -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"squeezeInBefore","comment":" Prepend items directly before the focussed location in the `HoleyFocusList`.\n\n```monospace\n      ğŸ’ğŸ‹\nğŸ ğŸ“ \\â†“/ <ğŸŠ> ğŸ‰ ğŸ‡\n```\n\n    import ListIs\n\n    HoleyFocusList.only 0\n        |> HoleyFocusList.squeezeInBefore [ -5, -4 ]\n        |> HoleyFocusList.squeezeInBefore [ -3, -2, -1 ]\n        |> HoleyFocusList.joinParts\n    --> ListIs.fromCons -5 [ -4, -3, -2, -1, 0 ]\n\n","type":"List.List a -> HoleyFocusList.HoleyFocusList focus a -> HoleyFocusList.HoleyFocusList focus a"},{"name":"toList","comment":" Flattens the `HoleyFocusList` into a list:\n\n    HoleyFocusList.only 456\n        |> HoleyFocusList.prepend [ 123 ]\n        |> HoleyFocusList.append [ 789 ]\n        |> HoleyFocusList.toList\n    --> [ 123, 456, 789 ]\n\nOnly use this if you need a list in the end.\nOtherwise, use [`joinParts`](#joinParts) to preserve some information about its length.\n\n","type":"HoleyFocusList.HoleyFocusList focus_ a -> List.List a"}],"binops":[]},{"name":"ListIs","comment":"\n\n\n## types\n\n@docs ListIs, Emptiable, NotEmpty\n@docs ListWithHeadType\n\n\n## create\n\n@docs empty, only, fromCons, fromTuple, fromList\n\n\n## scan\n\n@docs head, tail, length\n\n\n## modify\n\n@docs cons\n\n\n## glue\n\n@docs append, appendNonEmpty, concat\n\n\n### filter\n\n@docs when, whenJust\n\n\n## transform\n\n@docs map, map2, mapHead, mapTail, fold, foldWith, toList, toTuple\n\n","unions":[],"aliases":[{"name":"Emptiable","comment":" `Emptiable` marks lists that could be empty:\n\n    fromList : List a -> ListIs Emptiable a\n    fromList list =\n        case list of\n            [] ->\n                ListIs.empty\n\n            head :: tail ->\n                ListIs.fromCons head tail\n\n","args":[],"type":"MaybeIs.Nothingable { emptiable : () }"},{"name":"ListIs","comment":" Describes an empty or non-empty list, making it more convenient than any `Nonempty`.\n\nWe can require a [`NotEmpty`](#NotEmpty) for example:\n\n    toNonempty : ListIs NotEmpty a -> Nonempty a\n\nThis is equivalent to a [`MaybeIs`](MaybeIs) of a non-empty list tuple:\n\n    import MaybeIs exposing (MaybeIs(..))\n\n    ListIs.empty\n    --> MaybeIs.nothing\n\n    [ ... ]\n        |> ListIs.fromList\n        |> MaybeIs.map ListIs.head\n    --: MaybeIs Nothingable head_\n\n    toList : ListIs emptyOrNot_ a -> List a\n    toList list =\n        case list of\n            IsJust ( head_, tail_ ) ->\n                head_ :: tail_\n\n            IsNothing _ ->\n                []\n\n","args":["emptyOrNot","a"],"type":"ListIs.ListWithHeadType a emptyOrNot a"},{"name":"ListWithHeadType","comment":" Describes an empty or non-empty list where the head type can be different from the tail element type.\n\nUse [`ListIs`](#ListIs) if you have matching head and tail element types.\n\n`ListWithHeadType` is the result of:\n\n  - [`empty`](#empty)\n  - [`only`](#only)\n  - [`fromCons`](#fromCons)\n  - [`fromTuple`](#fromTuple)\n  - [`cons`](#cons)\n  - [`mapHead`](#mapHead)\n\nThis is equivalent to a [`MaybeIs`](MaybeIs) of a `( head, tail )` tuple:\n\n    import MaybeIs exposing (MaybeIs(..))\n\n    ListIs.empty\n    --> MaybeIs.nothing\n\n    MaybeIs.map ListIs.head\n    --: ListWithHeadType head emptyOrNot_ tailElement_\n    --: -> MaybeIs Nothingable head\n\n    tail : ListWithHeadType head_ NotEmpty tailElement -> List tailElement\n    tail listNotEmpty =\n        case listNotEmpty of\n            IsJust ( _, tailList ) ->\n                tailList\n\n            IsNothing _ ->\n                []\n\n","args":["head","emptyOrNot","tailElement"],"type":"MaybeIs.MaybeIs emptyOrNot ( head, List.List tailElement )"},{"name":"NotEmpty","comment":" `NotEmpty` can be used to require a non-empty list as an argument:\n\n    head : ListWithHeadType head NotEmpty tailElement_ -> head\n\n","args":[],"type":"MaybeIs.Just { notEmpty : () }"}],"values":[{"name":"append","comment":" Glue the elements of a `ListIs` to the end of a `ListIs`.\n\n    ListIs.fromCons 1 [ 2 ]\n        |> ListIs.append\n            (ListIs.fromCons 3 [ 4 ])\n    --> ListIs.fromCons 1 [ 2, 3, 4 ]\n\nPrefer this over [`appendNonEmpty`](#appendNonEmpty) if the piped `ListIs` is already known as `NotEmpty`\nor if both are `Emptiable`.\n\n","type":"ListIs.ListIs ListIs.Emptiable a -> ListIs.ListIs emptyOrNot a -> ListIs.ListIs emptyOrNot a"},{"name":"appendNonEmpty","comment":" Glue the elements of a `ListIs NotEmpty ...` to the end of a `ListIs`.\n\n    ListIs.empty\n        |> ListIs.appendNonEmpty\n            (ListIs.fromCons 1 [ 2 ])\n        |> ListIs.append\n            (ListIs.fromCons 3 [ 4, 5 ])\n    --> ListIs.fromCons 1 [ 2, 3, 4, 5 ]\n\nPrefer [`append`](#append) if the piped `ListIs` is already known as `NotEmpty`\nor if both are `Emptiable`.\n\n","type":"ListIs.ListIs ListIs.NotEmpty a -> ListIs.ListIs emptyOrNot_ a -> ListIs.ListIs ListIs.NotEmpty a"},{"name":"concat","comment":" Glue together a bunch of lists.\n\n    ListIs.fromCons\n        (ListIs.fromCons 0 [ 1 ])\n        [ ListIs.fromCons 10 [ 11 ]\n        , ListIs.empty\n        , ListIs.fromCons 20 [ 21, 22 ]\n        ]\n        |> ListIs.concat\n    --> ListIs.fromCons 0 [ 1, 10, 11, 20, 21, 22 ]\n\nFor this to return a `ListIs notEmpty`, there must be a non-empty first list.\n\n","type":"ListIs.ListWithHeadType (ListIs.ListIs emptyOrNot a) emptyOrNot (ListIs.ListIs tailListsEmptyOrNot_ a) -> ListIs.ListIs emptyOrNot a"},{"name":"cons","comment":" Add an element to the front of a list.\n\n    ListIs.fromCons 2 [ 3 ] |> ListIs.cons 1\n    --> ListIs.fromCons 1 [ 2, 3 ]\n\n    ListIs.empty |> ListIs.cons 1\n    --> ListIs.only 1\n\n","type":"consed -> ListIs.ListIs emptyOrNot_ a -> ListIs.ListWithHeadType consed ListIs.NotEmpty a"},{"name":"empty","comment":" A `ListIs` without elements.\n\nEquivalent to `MaybeIs.nothing`.\n\n","type":"ListIs.ListWithHeadType head_ ListIs.Emptiable tailElement_"},{"name":"fold","comment":" Reduce a List in a [direction](https://package.elm-lang.org/packages/lue-bird/elm-linear-direction/latest/).\n\n    import LinearDirection exposing (LinearDirection(..))\n\n    ListIs.fromCons 'l' [ 'i', 'v', 'e' ]\n        |> ListIs.fold LastToFirst String.cons \"\"\n    --> \"live\"\n\n    ListIs.fromCons 'l' [ 'i', 'v', 'e' ]\n        |> ListIs.fold FirstToLast String.cons \"\"\n    --> \"evil\"\n\n","type":"LinearDirection.LinearDirection -> (a -> acc -> acc) -> acc -> ListIs.ListIs emptyOrNot_ a -> acc"},{"name":"foldWith","comment":" A fold in a [direction](https://package.elm-lang.org/packages/lue-bird/elm-linear-direction/latest/)\nwhere the initial result is the first value in the `ListIs`.\n\n    import LinearDirection exposing (LinearDirection(..))\n\n    ListIs.fromCons 234 [ 345, 543 ]\n        |> ListIs.foldWith FirstToLast max\n    --> 543\n\n","type":"LinearDirection.LinearDirection -> (tailElement -> acc -> acc) -> ListIs.ListWithHeadType acc ListIs.NotEmpty tailElement -> acc"},{"name":"fromCons","comment":" Build a `notEmpty_` from its head and tail.\n","type":"head -> List.List tailElement -> ListIs.ListWithHeadType head notEmpty_ tailElement"},{"name":"fromList","comment":" Convert a `List a` to a `ListIs Emptiable a`.\n\n    [] |> ListIs.fromList\n    --> ListIs.empty\n\n    [ \"hello\", \"emptiness\" ] |> ListIs.fromList\n    --> ListIs.fromCons \"hello\" [ \"emptiness\" ]\n    --: ListIs Emptiable String\n\nWhen constructing from known elements, always prefer\n\n    ListIs.fromCons \"hello\" [ \"emptiness\" ]\n\n","type":"List.List a -> ListIs.ListIs ListIs.Emptiable a"},{"name":"fromTuple","comment":" Convert a non-empty list tuple `( a, List b )` to a `ListWithHeadType a notEmpty_ b`.\n\nEquivalent to `MaybeIs.just`.\n\n","type":"( head, List.List tailElement ) -> ListIs.ListWithHeadType head notEmpty_ tailElement"},{"name":"head","comment":" The first value in the `ListIs`.\n\n    ListIs.only 3\n        |> ListIs.cons 2\n        |> ListIs.head\n    --> 2\n\n","type":"ListIs.ListWithHeadType head ListIs.NotEmpty tailElement_ -> head"},{"name":"length","comment":" How many element there are.\n\n    ListIs.only 3\n        |> ListIs.cons 2\n        |> ListIs.length\n    --> 2\n\n","type":"ListIs.ListWithHeadType head_ emptyOrNot_ tailElement_ -> Basics.Int"},{"name":"map","comment":" Apply a function to every element.\n\n    ListIs.fromCons 1 [ 4, 9 ]\n        |> ListIs.map negate\n    --> ListIs.fromCons -1 [ -4, -9 ]\n\n","type":"(a -> b) -> ListIs.ListIs emptyOrNot a -> ListIs.ListIs emptyOrNot b"},{"name":"map2","comment":" Combine 2 `ListIs`s with a given function.\nIf one list is longer, its extra elements are dropped.\n\n    ListIs.map2 (+)\n        (ListIs.fromCons 1 [ 2, 3 ])\n        (ListIs.fromCons 4 [ 5, 6, 7 ])\n    --> List.fromCons 5 [ 7, 9 ]\n\n","type":"(a -> b -> combined) -> ListIs.ListIs emptyOrNot a -> ListIs.ListIs emptyOrNot b -> ListIs.ListIs emptyOrNot combined"},{"name":"mapHead","comment":" Apply a function to the head only.\n\n    ListIs.fromCons 1 [ 4, 9 ]\n        |> ListIs.mapHead negate\n    --> ListIs.fromCons -1 [ 4, 9 ]\n\n","type":"(head -> mappedHead) -> ListIs.ListWithHeadType head emptyOrNot tailElement -> ListIs.ListWithHeadType mappedHead emptyOrNot tailElement"},{"name":"mapTail","comment":" Apply a function to every element of its tail.\n\n    ListIs.fromCons 1 [ 4, 9 ]\n        |> ListIs.mapTail negate\n    --> ListIs.fromCons 1 [ -4, -9 ]\n\n","type":"(tailElement -> mappedTailElement) -> ListIs.ListWithHeadType head emptyOrNot tailElement -> ListIs.ListWithHeadType head emptyOrNot mappedTailElement"},{"name":"only","comment":" A `ListIs` with just 1 element.\n\n    ListIs.only \":)\"\n    --> ListIs.empty |> ListIs.cons \":)\"\n\n","type":"head -> ListIs.ListWithHeadType head notEmpty_ tailElement_"},{"name":"tail","comment":" Everything after the first value in the `ListIs`.\n\n    ListIs.only 2\n        |> ListIs.cons 3\n        |> ListIs.append (ListIs.fromCons 1 [ 0 ])\n        |> ListIs.tail\n    --> [ 2, 1, 0 ]\n\n","type":"ListIs.ListWithHeadType head_ ListIs.NotEmpty tailElement -> List.List tailElement"},{"name":"toList","comment":" Convert the `ListIs` to a `List`.\n\n    ListIs.fromCons 1 [ 7 ]\n        |> ListIs.toList\n    --> [ 1, 7 ]\n\n","type":"ListIs.ListIs emptyOrNot_ a -> List.List a"},{"name":"toTuple","comment":" Convert a `NotEmpty` to a non-empty list tuple `( a, List a )`.\n\nEquivalent to `MaybeIs.value`.\n\n","type":"ListIs.ListWithHeadType head ListIs.NotEmpty tailElement -> ( head, List.List tailElement )"},{"name":"when","comment":" Keep elements that satisfy the test.\n\n    ListIs.fromCons 1 [ 2, 5, -3, 10 ]\n        |> ListIs.when (\\x -> x < 5)\n    --> ListIs.fromCons 1 [ 2, -3 ]\n    --: ListIs Emptiable number_\n\n","type":"(a -> Basics.Bool) -> ListIs.ListIs emptyOrNot_ a -> ListIs.ListIs ListIs.Emptiable a"},{"name":"whenJust","comment":" Keep all `Just` values and drop all `Nothing`s.\n\n    ListIs.fromCons (Just 1) [ Nothing, Just 3 ]\n        |> ListIs.whenJust\n    --> ListIs.fromCons 1 [ 3 ]\n    --: ListIs Emptiable number\n\n    ListIs.fromCons Nothing [ Nothing ]\n        |> ListIs.whenJust\n    --> ListIs.empty\n\n","type":"ListIs.ListIs emptyOrNot_ (Maybe.Maybe value) -> ListIs.ListIs ListIs.Emptiable value"}],"binops":[]},{"name":"MaybeIs","comment":" `Maybe` with the ability to know at the type level whether it exists.\n\n    import MaybeIs exposing (just)\n\n    [ just 1, just 7 ]\n        --: List (MaybeIs just_ number_)\n        |> List.map MaybeIs.value\n    --> [ 1, 7 ]\n\n`MaybeIs` alone will probably not proof any useful,\nbut we can build cool type-safe data structures with it:\n\n    type alias ListIs emptyOrNot a =\n        MaybeIs emptyOrNot ( a, List a )\n\n    type alias NotEmpty =\n        MaybeIs.Just { notEmpty : () }\n\n    type alias Emptiable =\n        MaybeIs.Nothingable { emptiable : () }\n\n    empty : ListIs Emptiable a_\n\n    cons : ListIs emptyOrNot_ a -> a -> ListIs notEmpty_ a\n\n    head : ListIs NotEmpty a -> a\n\nThis is exactly how [`ListIs`](ListIs) is implemented.\n\n\n## types\n\n@docs MaybeIs, Just, Nothingable, CanBeNothing\n\n\n## create\n\n@docs just, nothing, fromMaybe\n\n\n## transform\n\n@docs map, map2, toMaybe, value, andThen, withFallback\n\n\n## type-level\n\n@docs branchableType\n\n","unions":[{"name":"CanBeNothing","comment":" The value attached to a `IsNothing`:\n\n  - [`Just`](#Just): that value is `Never`\n  - [`Nothingable`](#Nothingable): that value is `()`\n\nIt also has a simple type tag to make `MaybeIs` values distinct:\n\n    type alias NotEmpty =\n        MaybeIs.Just { notEmpty : () }\n\n    type alias ItemFocussed =\n        MaybeIs.Just { itemFocussed : () }\n\nRemember to update the tag after renaming an alias.\n\n","args":["valueIfNothing","tag"],"cases":[["CanBeNothing",["valueIfNothing"]]]},{"name":"MaybeIs","comment":" Like `Maybe` with type level information about whether it exists.\n\nSee [`Just`](#Just) and [`Nothingable`](#Nothingable).\n\n","args":["justOrNothing","a"],"cases":[["IsNothing",["justOrNothing"]],["IsJust",["a"]]]}],"aliases":[{"name":"Just","comment":" Only allow `MaybeIs`s that certainly exist as arguments.\n\n    import MaybeIs exposing (Just, MaybeIs)\n\n    head : MaybeIs (Just tag_) ( a, List a ) -> a\n    head =\n        MaybeIs.value >> Tuple.first\n\nSee [`CanBeNothing`](#CanBeNothing) and [`ListIs`](ListIs).\n\n","args":["tag"],"type":"MaybeIs.CanBeNothing Basics.Never tag"},{"name":"Nothingable","comment":" `MaybeIs (Nothingable tag)`: The value could exist, could also not exist.\n\nSee [`CanBeNothing`](#CanBeNothing).\n\n","args":["tag"],"type":"MaybeIs.CanBeNothing () tag"}],"values":[{"name":"andThen","comment":" Chain together many computations that may fail.\n\n    maybeString\n        |> MaybeIs.andThen parse\n        |> MaybeIs.andThen extraValidation\n\n    parse : String -> MaybeIs Nothingable Parsed\n    extraValidation : Parsed -> MaybeIs Nothingable Validated\n\n","type":"(a -> MaybeIs.MaybeIs justOrNothing b) -> MaybeIs.MaybeIs justOrNothing a -> MaybeIs.MaybeIs justOrNothing b"},{"name":"branchableType","comment":" When using `(Just ...)` for an argument:\n\n    theShorter :\n        ListIs NotEmpty a\n        -> ListIs emptyOrNot a\n        -> ListIs emptyOrNot a\n    theShorter aList bList =\n        if ListIs.length bList > ListIs.length aList then\n            bList\n\n        else\n            --â†“ `NotEmpty` but we need `emptyOrNot`\n            aList\n\nto make both branches return `emptyOrNot`, we could use\n\n    else\n        aList |> ListType.toTuple |> ListType.fromTuple\n\nalso known as: necessary code that nobody will understand.\n\n    else\n        aList |> MaybeIs.branchableType\n\nis a bit better.\n\nğŸ’™ Found a better name? â†’ open an issue.\n\n","type":"MaybeIs.MaybeIs (MaybeIs.Just tag_) a -> MaybeIs.MaybeIs just_ a"},{"name":"fromMaybe","comment":" Convert a `Maybe` to a `MaybeIs`.\n","type":"Maybe.Maybe a -> MaybeIs.MaybeIs (MaybeIs.Nothingable tag_) a"},{"name":"just","comment":" A `MaybeIs` that certainly exists.\n\n    MaybeIs.just \"you\" |> MaybeIs.value\n    --> \"you\"\n\n","type":"value -> MaybeIs.MaybeIs just_ value"},{"name":"map","comment":" Transform the value in the `MaybeIs` using a given function:\n\n    import MaybeIs exposing (just, nothing)\n\n    MaybeIs.map abs (just -3) --> just 3\n    MaybeIs.map abs nothing --> nothing\n\n","type":"(a -> b) -> MaybeIs.MaybeIs justOrNothing a -> MaybeIs.MaybeIs justOrNothing b"},{"name":"map2","comment":" If all the arguments exist, combine them using a given function.\n\n    import MaybeIs exposing (just, nothing)\n\n    MaybeIs.map2 (+) (just 3) (just 4) --> just 7\n    MaybeIs.map2 (+) (just 3) nothing --> nothing\n    MaybeIs.map2 (+) nothing (just 4) --> nothing\n\n","type":"(a -> b -> combined) -> MaybeIs.MaybeIs justOrNothing a -> MaybeIs.MaybeIs justOrNothing b -> MaybeIs.MaybeIs justOrNothing combined"},{"name":"nothing","comment":" Nothing here.\n","type":"MaybeIs.MaybeIs (MaybeIs.Nothingable tag_) a_"},{"name":"toMaybe","comment":" Convert a `MaybeIs` to a `Maybe`.\n","type":"MaybeIs.MaybeIs justOrNothing_ a -> Maybe.Maybe a"},{"name":"value","comment":" Safely extracts the `value` from a `MaybeIs Just value`.\n\n    import MaybeIs exposing (just)\n\n    just (just (just \"you\"))\n        |> MaybeIs.value\n        |> MaybeIs.value\n        |> MaybeIs.value\n    --> \"you\"\n\n","type":"MaybeIs.MaybeIs (MaybeIs.Just tag_) value -> value"},{"name":"withFallback","comment":" Lazily use a fallback value if the `MaybeIs` is [`nothing`](#nothing).\n\n    import Dict\n\n    Dict.empty\n        |> Dict.get \"Tom\"\n        |> MaybeIs.fromMaybe\n        |> MaybeIs.withFallback (\\() -> \"unknown\")\n    --> \"unknown\"\n\nHint: `MaybeIs.withFallback never` is equivalent to `MaybeIs.value`.\n\n","type":"(canBeNothing -> value) -> MaybeIs.MaybeIs (MaybeIs.CanBeNothing canBeNothing tag_) value -> value"}],"binops":[]}]